import {
    publish as c
} from '@uxland/event-aggregator/event-aggregator';

var p = 'UXL-FETCH:INVALID_CREDENTIALS_EVENT', d = 'UXL-FETCH:INVALID_REQUEST_EVENT', u = async t => {
    var e = () => new Promise(e => e());
    if (t.ok) return t;
    {
        let a;
        try {
            var n = await t.json();
            a = {
                ...new Error(),
                data: n,
                status: t.status,
                statusText: t.statusText
            };
        } catch (e) {
            a = {
                ...new Error(),
                status: t.status,
                statusText: t.statusText
            };
        }
        throw 401 === t.status ? (await e(), c(p, a)) : (await e(), c(d, a)), a;
    }
}, R = 'Content-Type', h = 'application/json', x = e => -1 !== e.headers?.get(R)?.indexOf(h), m = async (e, a = []) => x(e) ? await e.json().then(e => a.reduce((e, a) => a(e), e)) : await e.text(), l = function(e) {
    return null == e ? '' : encodeURIComponent(e);
}, g = function(e) {
    let a = [];
    for (var t in e) {
        var n = e[t];
        a.push(null !== n && 'object' == typeof n ? `${encodeURIComponent(t)}=${JSON.stringify(n)}` : encodeURIComponent(t) + '=' + l(n));
    }
    return a.join('&');
}, N = /^([a-z][a-z0-9+\-.]*:)?\/\//i, y = {}, E = function(e, a, t = {}) {
    if (N.test(a)) return a;
    a = (e || '') + (a || ''), t = g({
        ...y,
        ...t
    });
    return t ? a + '?' + t : a;
};

import {
    isNil as C,
    mergeDeepRight as _
} from 'ramda';

var a, f = (e, a) => C(a) ? e : _(e, a), I = 'application/json', i = [], T = {
    t: I
}, n = {
    headers: {
        ...T
    },
    credentials: 'include',
    mode: 'cors'
}, z = e => a = e, J = () => a, B = e => {
    i.push(e);
}, F = () => i, X = e => {
    n = {
        ...n,
        ...e
    };
}, Y = () => n, k = e => {
    n = {
        ...n,
        headers: {
            ...n.headers,
            ...e
        }
    };
}, $ = () => n?.headers, G = e => {
    n?.headers[e] && delete n.headers[e];
}, K = () => {
    n = {
        ...n,
        headers: {
            ...T
        }
    };
}, M = async (e, t, r) => {
    t = await fetch(E(a, e, r), f(t, n)), t = await u(t);
    return await m(t, i);
};

export {
    p as INVALID_CREDENTIALS_EVENT,
    d as INVALID_REQUEST_EVENT,
    X as configure,
    M as doFetch,
    J as getBaseUrl,
    Y as getConfiguration,
    $ as getHeaders,
    F as getResponseHandlers,
    B as registerResponseHandler,
    G as removeHeader,
    K as resetHeaders,
    z as setBaseUrl,
    k as setHeaders
};